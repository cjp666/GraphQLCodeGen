/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the Tocsoft.GraphQLCodeGen toolchain https://github.com/tocsoft/GraphQLCodeGen
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming


interface fetchClient {
    fetch(url: RequestInfo, init: RequestInit): Promise<Response>
}

class GraphQLResponse
{
    data: any
    errors: Array<{ message: string }>
}

function GitHubClientError(message:string, httpResponse:Response, graphqlResponse?: GraphQLResponse) {
    this.name = 'GitHubClientError';
    this.message = message || 'Error fetching graphql response';
    this.stack = (new Error()).stack;
    this.httpResponse = httpResponse;
    if(graphqlResponse && graphqlResponse.errors){
        this.errors = graphqlResponse.errors.map(x=>x.message);
    }
  }
  GitHubClientError.prototype = Object.create(Error.prototype);
  GitHubClientError.prototype.constructor = GitHubClientError;
  
export { GitHubClientError }

export default class GitHubClientClient {

    constructor(public client: fetchClient, public url: string) { }
	
	single() : Promise<SingleResult>{
        return this.client.fetch(this.url, {
            method : 'POST',
            body : JSON.stringify({
                query : `query  {
  viewer {
    name
  }
}`,
                variables : {
                }
            })
        }).then(response=>{
            if(response.status != 200){
                // error result
                throw new GitHubClientError("http error running 'single', see httpResponse for more details.", response)
            }else{
                return response.json().then((json:GraphQLResponse)=>{
                    
                    if(json.errors && json.errors.length > 0){
                        throw new GitHubClientError("graphql error(s) running 'single', see errors collection fro more details", response, json)
                    }
                    
                    return SingleResult.fromJS(json.data);
                })
            }
        })
    }	
}

export class GqlQueryUserResult {
		name :string;

    static fromJS(json:any):GqlQueryUserResult{
        if(json == null || json == undefined){
            return null;
        }
        
        var result = new GqlQueryUserResult();

	result.name = json["name"];

        return result;
    }
}

export class SingleResult {
		viewer? :GqlQueryUserResult;

    static fromJS(json:any):SingleResult{
        if(json == null || json == undefined){
            return null;
        }
        
        var result = new SingleResult();

result.viewer= GqlQueryUserResult.fromJS(json["viewer"]);

        return result;
    }
}


